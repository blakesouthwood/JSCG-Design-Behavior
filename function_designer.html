<html>
<head>
<script>

/*

*/

</script>
</head>
<body><br><br><br>
<b>JS Function Design Tool</b><br>
<br>
All code does something (what behavior it does when running)that <br>
can be described as human meaning.<br>
My goal is to make a logic checker just like a spell checker.<br><br>
My ultimate goal is to create a new (working) function in one minute with no bugs.<br>
And this will be done by designing first how the algorithm will work<br>
and after that is conquered by merely describing what the function's behavior <br>
will be when it runs with stated inputs and outputs.<br><br>
I revere Robert Floyd's paper - "Assigning Meaning To Programs."<br><br>
My favorite quote from Dijkstra is "for any problem capable of algorithm solution<br>
We must not forget that it is not our business to make programs, it is <br>
our bueinss to design clases of computations that will display<br>
a desired behavior. "<br><br>



I realized that bugs are born during the design phase<br>
and translation process in a programmer's mind translating<br>
English intent what they are trying to do into boolean logic<br>
through the vehicle of JavaScript and the error isn't typically<br>
discovered until the code is run later down the road.<br>
This made me think of two things - first coding is really translating<br>
what to do (some behavior) into boolean logic starting from<br>
square one each time and that seemed like a complete waste.<br>
Two the programmers if forced to think in human thinking <br>
which they would definitely prefer and think like the machine<br>
which is more problematic. Now Dijkstra wrote that the way the<br>
machine works is predictable and along that vein though it's predictable<br>
the complexity of so much boolean logic invites errors made by<br>
the imperfect human so if the information of the translation of<br>
what trying to do into a small chunk of source code (bolean logic)<br>
would save time and prevent bugs through reuse and reduced<br>
thinking and reduced typing.<br>


Quote from Edsger Dijkstra from his Turing Award Speech 1972 The Humble Programmer.<br>
"The vision is that, well before the seventies have run to completion, we shall<br>
 be able to design and implement the kind of systems that are now straining our <br>
 programming ability, at the expense of only a few percent in man-years of what <br>
 they cost us now, and that besides that, these systems will be virtually free of bugs.<br>
  These two improvements go hand in hand. In the latter respect software seems to be<br>
   different from many other products, where as a rule a higher quality implies a <br>
   higher price. Those who want really reliable software will discover that they <br>
   must find means of avoiding the majority of bugs to start with, and as a result <br>
   the programming process will become cheaper. If you want more effective programmers,<br>
    you will discover that they should not waste their time debugging, they should not <br>
    introduce the bugs to start with. In other words: both goals point to the same change.""
<br><br>
"I now suggest that we confine ourselves to the design and implementation of intellectually<br>
 manageable programs. If someone fears that this restriction is so severe that we cannot<br>
  live with it, I can reassure him: the class of intellectually manageable programs is <br>
  still sufficiently rich to contain many very realistic programs for any problem capable<br>
   of algorithmic solution. We must not forget that it is not our business to make programs, <br>
   it is our business to design classes of computations that will display a desired behaviour.<br>
    The suggestion of confining ourselves to intellectually manageable programs is the <br>
    basis for the first two of my announced six arguments.""<br><br>
<br>
"Argument three is based on the constructive approach to the problem of program correctness. <br>
Today a usual technique is to make a program and then to test it. But: program testing <br>
can be a very effective way to show the presence of bugs, but is hopelessly inadequate<br>
 for showing their absence. The only effective way to raise the confidence level of a <br>
 program significantly is to give a convincing proof of its correctness. But one should <br>
 not first make the program and then prove its correctness, because then the requirement <br>
 of providing the proof would only increase the poor programmer’s burden. On the contrary:<br>
  the programmer should let correctness proof and program grow hand in hand. Argument three <br>
  is essentially based on the following observation. If one first asks oneself what the <br>
  structure of a convincing proof would be and, having found this, then constructs a <br>
  program satisfying this proof’s requirements, then these correctness concerns turn <br>
  out to be a very effective heuristic guidance. By definition this approach is only <br>
  applicable when we restrict ourselves to intellectually manageable programs, but it<br>
   provides us with effective means for finding a satisfactory one among these.<br><br>

Argument four has to do with the way in which the amount of intellectual effort needed <br>
to design a program depends on the program length. It has been suggested that there <br>
is some kind of law of nature telling us that the amount of intellectual effort needed <br>
grows with the square of program length. But, thank goodness, no one has been able to<br>
 prove this law. And this is because it need not be true. We all know that the only <br>
 mental tool by means of which a very finite piece of reasoning can cover a myriad cases <br>
 is called “abstraction”; as a result the effective exploitation of his powers of<br>
  abstraction must be regarded as one of the most vital activities of a competent<br>
   programmer. In this connection it might be worth-while to point out that the <br>
   purpose of abstracting is not to be vague, but to create a new semantic level in <br>
   which one can be absolutely precise. Of course I have tried to find a fundamental <br>
   cause that would prevent our abstraction mechanisms from being sufficiently <br>
   effective. But no matter how hard I tried, I did not find such a cause. As a <br>
   result I tend to the assumption —up till now not disproved by experience— that <br>
   by suitable application of our powers of abstraction, the intellectual effort <br>
   needed to conceive or to understand a program need not grow more than proportional<br>
    to program length. But a by-product of these investigations may be of much greater<br>
     practical significance, and is, in fact, the basis of my fourth argument. <br>
     The by-product was the identification of a number of patterns of abstraction<br>
      that play a vital role in the whole process of composing programs. Enough is<br>
       now known about these patterns of abstraction that you could devote a lecture<br>
        to about each of them. What the familiarity and conscious knowledge of these<br>
         patterns of abstraction imply dawned upon me when I realized that, had they <br>
         been common knowledge fifteen years ago, the step from BNF to syntax-directed<br>
          compilers, for instance, could have taken a few minutes instead of a few years.<br>
           Therefore I present our recent knowledge of vital abstraction patterns as the <br>
           fourth argument.""

<br><br>
I am aware that this software project is ambitious but it will become vital <br>
to keep up with the growing demand for writing JavaScript that is bug free of logic bugs<br>
inside the function level to speed up unit testing. <br><br>
The pseudocode would be store-able and associated with the working function.<br>
The objective is designing a function's running behavior with no logic bugs. <br>
This is achieved by working above the boolean logic level and reuse. <br>
It  works by describing  how it will work using literate programming explained to a human.<br>
Using English steps or pseudocode to get the logic straight. Logic that works right will be learned<br>
not in the literal form (till later) but added to a knowledge database of the working translation<br>
from intent what to do and pseudocode and source code in JavaScript.<br>
<br>
I am fully aware that what I am proposing means tracking intially thousands and eventually<br>
billions and perhaps trillions of chunks of code and pretranslated intent to code.<br>
And the tracking of bad logic based on the design of pseudocode.<br>
The way I think of this problem is as Alan Turings Enigma translator at Betchley Park, Britain in WW2.<br>
It's all on how you think about a problem. It's just encryting meaning and deciphering<br>
the translation.<br>
To be absolutely clear this is for the sole purpose of preventing logic bugs and creating<br>
a way of translating English literate programming descriptions into correct pseudocode<br>
which is then translated into JavaScript to build new functions faster.<br>
(This is really a JS Code Generator via design tool reuse and knowledge of translated intent to JS)<br>
The only viable solution is that it continues to gain more knowledge. It will initially <br>
be coded in fuzzy logic and then use true AI using some Python (that's the goal).<br><br>
I want to write code ten times faster but reduce <b>logic bugs</b> at the same time.<br>
This is only possible with reuse and by describing what the code steps do in English.<br>
At no point does this program actually understand English - just matching word patterns.<br>
<br>
One feature of this tool will be translating human intent <b>what trying to do</b><br>
into steps in literate programming English and structured psuedocode and JavaScript <br>
(including standard library methods).</br><br>
All code is boolean logic. The function designer's purpose<br>
is to reuse boolean logic that does something and has been tested<br>
so that programmers don't have to waste time retranslating their intent<br>
what to do into how it will do it in JavaScript when it's already been solved.<br>
The way that this will work is at the design level(s) before code is written.<br>
The reality is that each function has a blueprint that can be expressed<br>
with several different representations and abstraction levels, and a fucntion<br>
can also be represented by the dynamic behavior it creates when it runs.<br>
The objective is to have a flexible approach for the taste and style and philosophy<br>
of each programmer so that they can choose the view that they are more comfortable with<br>
to include a high level expressive pseudocode above the JavaScript level.<br>
<br><br>
The hope is that the programmers won't have to spend so much time knee deep<br>
in thinking through how a function will work  and then spend precious time<br>
trying to get it to work right and debugging it due a flawed design<br>
or God forbid no design - or a design that it done on-the-fly or as Allen Cooper<br>
wrote "The problem with programmers is that they build code the same<br>
way that beavers build dams - they design as they go." And the problem<br>
with this approach is spending 50% of programming time debugging.<br>
<br><br>
Still another objective of this new approach is the generated/reused JavaScript<br>
will be fully commented what it does, how it works, and with expressive pseudocode.<br>
Fred Brooks wrote that the only two ways that are known to speed up<br>
software development (coding) is by reducing time thinking, reducing bugs,<br>
reusing code (which means human knowledge how to create machine behavior)<br>
and using high level langauges and interactive design.<br>

The most difficult bugs in programming are logic bugs and<br>
so this is my attempt at preventing future bugs by focusing<br>
on the design of an algorithm and how it will work and what it <br>
will do to create machine behavior with reuse of human knowledge<br>
from past successes.<br>
<br>
The Function Designer is meant to be a tool to design<br>
a function in JavaScript using multiple abstraction levels. <br>
The main goal is to reduce logic bugs at the source by designing the <br>
machine behavior that the function will perform at first<br>
in literate level English. What it will do. Then how it will work<br>
and then in steps and pseudocode. The point is to work above<br>
the actual JavaScript language in this context. This is to save<br>
time from thinking actually in JavaScript and focusing rather<br>
on how a human thinks of the function algorithm.<br>
The overall objective is to reuse working boolean logic from preexisting<br>
definitions of steps and pseudocode and running machine behavior descriptions<br>
rather than writing new fresh boolean logic. And to reuse boolean logic<br>
as much as possible. For this to work we have to focus on the design<br>
of a function with steps and in pseudocode to break free from the constraints<br>
of thinking in the programming language - JavaScript - and boolean logic thinking<br>
whereby we are focused on telling the machine in boolean logic how to do<br>
something at an incredibly low level to be read by the arthmetic logic unit<br>
and we change our perspective to what we want to say or to be done - a subtask.<br>
This is described as literate level programming from Dr. Don Knuth at Stanford.<br>

<br><br>
I was working on my JS Replay Code Path program to be able to pinpoint<br>
where a logic bug was based on what the code was actually doing<br>
(after the code ran) as opposed to what I thought that it has been programmed<br>
to do in boolean logic in JavaScript. However the bug was caused by<br>
a human programmer that either designed their boolean logic to represent<br>
machine behavior incorrectly or not thoroughly enough or implimented the<br>
source code not corresponding perfectly to their design.<br>
And it occurred to me that since I was going through the<br>
code after it has run that to prevent the logic bugs in the<br>
future it would be prudent to design the logic and the behavior<br>
it creates so as to be able to reuse the good logic that creates<br>
the desired designed running machine behavior.<br>
<br>
The more I thought about it the more I realized that <br>
writing all code for the most part is writing new code instructions<br>
after converting in the programmer's mind the intent what they <br>
want the code to do into how it will work (sometimes in pseudocode)<br>
and then into source code and boolean logic calculations.<br>
<br>So as Tony Hoare wrote "The best way to reduce bugs/<b>debugging</b> [which implies boolean logic] is with<br>
successful design of the program and careful documentation <br>
during construction of the code. <br>
The documentation will give assistance in expressing how the program is to run<br>
but also what it is intended to accomplish (do) . And it should be expressed<br>
at various levels.<br><br>
The careful <b>documentation</b> is to explan it to a  human reader the way<bf>
in which a program works. <br>
Further, Tony Hoare wrote, " <b>Design</b> is deciding what the program<br>
is to do. And often it's just as difficult in how to do it and dividing a <br>
complex task into substask and specify the purpose of each part. <br>


<br><br>
JS Function Designer is a boolean logic designer program<br>
that will be interactive and access a knowledgebase.<br>
<br>
There will be multiple ways of representing functions to build them<br>
but as John Backus said we need a powerful new methodology in how we<br>
think about programs and current programming languages (1973) lack<br>
expressiveness and cause unnecessary confusion.<br>
Marvin Minsky mentioned the importance of form over content and most<br>
importantly there is too much syntax in programming languages.<br>
<br><br>
One aspect I plan to achieve is creating a translator from human intent<br>
what to do described in Literate Programming (English) whereby the programmer<br>
writes what they want the computer to do told to another human to read.<br>
This is a completely different perspective.<br>
<br><br>

Further this tool will have a search tool for if what the programmer<br>
is trying to represent/describe already exists. So this will <br>
be linked to a DB looking for running behavior description and<br>
what a function does or subtask within a function does<br>
to save time and reuse knowledge.<br>
At the step level it will utilize Literate level programming short English<br>
which will be matched both with pseudocode and JavaScript code.<br>
Realize of course that JavaScript code is but one of many representations<br>
of boolean logic for a function. And realize that till now pseudocode<br>
hasn't been standardized. <br>
I will start with the translation  aspect of literate to pseudocode and pseudocode<br>
to JS to begin with.<br>

<br>
Quotes from the CS Legends.<br>
<br>
<b>
When someone says "I want a programming language in which I need <br>
only say what I wish done," give him a lollipop.</b><br>
  Alan Perlis <br>

<br>
John Backus<br>
will make it possible to say what you want done rather than how<br>
 to do it.<br>
 backus   ##########################################<br>
 new methodology in how we think about the program<br>
<br>
 Grace Hopper<br>
we need to define the problem instead of the procedures<br>
relationships processes<br>
<br>
 Watts Humphrey translator between human and system and<br>
what you want to do<br>
<br>
 Don Knuth instead of telling the computer what we want to do (thru code instructions)<br>
 rather why don't we tell another human what we want the comptuer to do - that was<br>
 his breakthrough description paradigm shift.<br>
<br>
Tony Hoare Stanford Paper<br>
<br>
Program design. The first, and very difficult, aspect of design is<br>
 deciding what the program is to do, and formulating this as a clear,<br>
  precise, and acceptable specification.<br>
<br><br>
  Falkolf #####################=======<br>
There is apparently a gap between the way people would like to think,[intent]<br>
 and the way machines do things[boolean logic].<br>

<br>
a programming language that I can ...<br>
/ /Perlis  ...  say what I want done<br><br>
// Backus  ...  say what you want done rather than how to do it<br><br>
// Backus  ...  new methodology in how we think about the program<br><br>
// Hopper  ...  we need to define the problem instead of the procedures<br><br>
               relationships processes//implying what trying to do<br><br>
// Watts Humphrey... translator between human and system(machine) and what you want to do<br><br>
// <keygen name="name" challenge="string" keytype="RSA" keyparams="medium">uth   ... tell another human what we want the computer to do literate programming<br><br>
// Hoare   ...  expressing how the program is to run and what it is intended to accomplish;<br>
                 expressed at various levels,<br><br>
<br><br>
 //Jean Sammet  ... a large decrease in the amount of detail a user must provide.<br>
               more statements about what is to be done and fewer details on how to do it.<br>
               English programming.<br>
 //Humphrey ...designing a language as a translator between human beings and machines.<br><br>
 ##########################################################<br>
 Falkoff    ... a gap between  way people would like to think,<br>
                 and the way machines do things.<br>
<br><br>

 Dijkstra ...  what the algorithmn does for you, and how it works, we make machine behavior<br>
<br>
 Marvin Minsky ...progrmaming languages of the future will<br>
                  be more concerned with goals and less with procedures<br>
                  specified by the programmer<br>
                   ##############################################<br><br>
Robin Milner ... what programmers would like to "think" about<br>
                 "what to do rather than how to do it"<br>
<br><br>
Hopper      .... the program exists at several levels<br><br>
<br>
Finally, Fred Brooks wrote that the only way to speed up software productivity -<br>
the so called "No Silver Bullet" to speed up software productivity(speed of production 10X)<br>
 is by reducing the time spent "thinking" (to design, build, code, debug, read, etc) and increasing<br>
reuse [of code and knoweldge to make that code behavior] and high level languages.<br>
But my initial idea for this project was to reduce boolean logic bugs by reusing stored<br>
translations of pseudocode into JS code with a generously large standard library of JS methods.<br>

</body>
</html>
